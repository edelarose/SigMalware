using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Diagnostics;

namespace SigMalware
{
    public partial class TaskManager : Form
    {
        #region User-Defined Variables
        public static TaskManager objtaskmgr;
        public string machineName = Environment.MachineName.ToString();
        public System.Threading.Timer t = null;
        public System.Threading.Timer tclr = null;
        public bool erroroccurred = false;
        #endregion
        public TaskManager()
        {
            InitializeComponent();
            Process taskProcess = new Process();
        }
        public void FillTaskList()
        {
            Process[] Prc = null;
            Cursor.Current = Cursors.WaitCursor;
            try
            {
                //clear any items already in the box
                listProcesses.Items.Clear();
                Prc = Process.GetProcesses(machineName);
            }
            catch(Exception e)
            {
                MessageBox.Show("Error" + e.Message);
            }
                int threadsCount = 0;
                foreach (Process process in Prc)
                {
                    try
                    {
                        string[] prcDetails = new string[]{process.ProcessName, process.Id.ToString(), process.StartTime.ToShortTimeString(), 
                        process.TotalProcessorTime.Duration().Hours.ToString()+":"+process.TotalProcessorTime.Duration().Minutes.ToString()+":"+
                        process.TotalProcessorTime.Duration().Seconds.ToString(), (process.WorkingSet/1024).ToString() + "k", (process.PeakWorkingSet/1024).ToString()+"k",
                        process.HandleCount.ToString(), process.Threads.Count.ToString()};
                        ListViewItem proc = new ListViewItem(prcDetails);
                        listProcesses.Items.Add(proc);
                        threadsCount += process.Threads.Count;
                    }
                    catch { }
                }
                statusBar.Panels[0].Text = "Processes: " + Prc.Length.ToString();
                statusBar.Panels[1].Text = "Threads: " + (threadsCount + 1).ToString();
            Cursor.Current = Cursors.Default;
        }
        private void TaskManager_Load(object sender, EventArgs e)
        {
            machineName = ".";
            FillTaskList();
        }
        //new process
        private void menuItemNew_Click(object sender, EventArgs e)
        {
        }
        //end process
        private void menuItemEnd_Click(object sender, EventArgs e)
        {
            if (listProcesses.SelectedItems.Count >= 1)
            {
                try
                {
                    int selectedpid = Convert.ToInt32(listProcesses.SelectedItems[0].SubItems[1].Text.ToString());
                    Process.GetProcessById(selectedpid, machineName).Kill();
                }
                catch
                {
                }

            }
        }
        private void menuItemExit_Click(object sender, EventArgs e)
        {
            Application.Exit();
        }
        private void menuOptionsTop_Click(object sender, EventArgs e)
        {
            if (menuOptionsTop.Checked)
            {
                menuOptionsTop.Checked = false;
            }
            else
            {
                menuOptionsTop.Checked = true;
            }
        }
        private void menuOptionsHide_Click(object sender, EventArgs e)
        {
            if (menuOptionsHide.Checked)
            {
                menuOptionsHide.Checked = false;
            }
            else
            {
                menuOptionsHide.Checked = true;
            }
        }
    }
}
